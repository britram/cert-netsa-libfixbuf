
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>fixbuf- Documentation</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
        <link rel="stylesheet" type="text/css" href="../../site/style.css" />
        <link rel="stylesheet" type="text/css" href="doxygen.css">
        <link rel="stylesheet" type="text/css" href="tabs.css">
</head>
<body>
    <div id="p-body">
      <div id="l-header">
        <img src="../../site/sei-logo.png" id="l-sei-logo"
            alt="Software Engineering Institute | Carnegie Mellon&copy;" />
        <div id="l-netsa-logo"><a id="l-netsa-name" href="../../index.html"><b>CERT NetSA Security Suite</b></a></div>
        <div id="l-netsa-motto">Monitoring for Large-Scale Networks</div>
        <h1 class="l-page-title">fixbuf</h1>
        <span id="l-subtitle">Documentation</span>
      </div><!-- l-header -->
      <div id="l-content">
        <div id="l-sidebar">
          <div class="p-sidebar-section">
            <h1><a href="../index.html">fixbuf</a></h1>
            <ul>
              <li><a href="index.html">Documentation</a></li>
              <li><a href="../download.html">Downloads</a></li>
	      <li><a href="../../pyfixbuf/index.html">pyfixbuf</a></li>
            </ul>
          </div><!-- p-sidebar-section -->
        </div><!-- l-sidebar -->
      <div id="top"> <!-- need this for doxygen -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">UDP Collectors </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>How-To Collect IPFIX over UDP:</p>
<p>It is not recommended to use UDP for IPFIX transport, since UDP is not a reliable transport protocol, and therefore cannot guarantee the delivery of messages. libfixbuf stores sequence numbers and reports potential loss of messages. Templates over UDP must be re-sent at regular intervals. Fixbuf does not automatically retransmit messages at regular intervals, it is left to the application author to call <a class="el" href="public_8h.html#a4e0c42fc80985c048190203257697ab6" title="Export all external templates in the current domain of a given session. ">fbSessionExportTemplates()</a>. In accordance with RFC 7011, the templates should be resent at least three times in the Template refresh timeout period. Make sure the record size does not exceed the path MTU. libfixbuf will return an error if the message exceeds the path MTU.</p>
<p>A UDP collector session is associated with a unique IP, observation domain pair. UDP sessions timeout after 30 minutes of inactivity. When a session times out, all templates and state are discarded, this includes any related NetFlow v9 templates and/or state. libfixbuf will discard any data records for which it does not contain a template for. Template IDs are unique per UDP session (IP and Observation Domain.) Once templates are refreshed, old templates may not be used or referenced by the collecting session. A UDP collector manages multiple sessions on one collector and fBuf. If the application is using the <a class="el" href="public_8h.html#a4313f40737bf2a6ab1db94693119312c">fbListenerAppInit_fn</a> and <a class="el" href="public_8h.html#a301cd8ac20e8e02e05e3b279ff50a7eb">fbListenerAppFree_fn</a> functions to maintain context per session, it is necessary to call <a class="el" href="public_8h.html#ad9fa506279884348752111ff3bb52882" title="Retrieve the application context associated with a collector. ">fbCollectorGetContext()</a> after each call to <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a> to receive the correct context pointer (as opposed to calling it after <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener. ">fbListenerWait()</a> returns in the TCP case). If the application needs to manage context PER SESSION, the application must turn on multi-session mode w/ <a class="el" href="public_8h.html#a1b18e9e1ccb41a90189125042c952de9" title="Attempt to maintain backwards compatibility with UDP. ">fbCollectorSetUDPMultiSession()</a> (this allows for backwards compatibility with old applications.) Previously, the appinit() function was called only from <a class="el" href="public_8h.html#a68a2e34a62fbfe7fe37dffa8b6b05048" title="Allocate a listener. ">fbListenerAlloc()</a> for UDP connections, which did not allow the application the peer information. The appinit() function is now called during <a class="el" href="public_8h.html#a68a2e34a62fbfe7fe37dffa8b6b05048" title="Allocate a listener. ">fbListenerAlloc()</a> (with a NULL peer address) and also when a new UDP connection is made to the collector, giving the application veto power over session creation. If the application does not call <a class="el" href="public_8h.html#a1b18e9e1ccb41a90189125042c952de9" title="Attempt to maintain backwards compatibility with UDP. ">fbCollectorSetUDPMultiSession()</a>, the application will not receive the callback to it's appinit() function, which only allows the application to set one context pointer on all sessions. Likewise, appfree() is only called once, when the collector is freed, if not in multi-session mode. If the application is in multi-session mode, appfree() will be called once for each session when the collector is freed AND anytime a session is timed out.</p>
<p>Note: If the appinit() function returns FALSE, libfixbuf will reject any subsequent messages from the peer address, observation domain until the timeout period has expired. If the appinit() function should reject a "connection" the application should set the error code to FB_ERROR_NLREAD and return FALSE. Example usage: </p><div class="fragment"><div class="line">g_set_error(error, <a class="code" href="public_8h.html#a16875886e559694c2a5d80cc1b9e00de">FB_ERROR_DOMAIN</a>, <a class="code" href="public_8h.html#a11335d44d4833a94788908cc0e019c32">FB_ERROR_NLREAD</a>, <span class="stringliteral">&quot;some msg&quot;</span>);</div></div><!-- fragment --><p>To only accept IPFIX from one host without using the appinit() and appfree() functions, it is encouraged to use <a class="el" href="public_8h.html#ac39b5a9a1eb9e8c8feaa9922cf73b300" title="Set the collector to only receive from the given IP address over UDP. ">fbCollectorSetAcceptOnly()</a>. UDP messages received from other hosts will return FB_ERROR_NLREAD. The application should ignore errors with this error code by clearing the error and calling <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a>. </p>
</div></div><!-- contents -->
      </div><!-- l-content -->
      <div id="l-footer">&copy; 2006-2018 Carnegie Mellon University</div>
    </div><!-- p-body -->
</body>
</html>
